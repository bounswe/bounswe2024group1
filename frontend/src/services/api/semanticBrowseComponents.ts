/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.2
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useSemanticBrowseContext,
  SemanticBrowseContext,
} from "./semanticBrowseContext";
import type * as Fetcher from "./semanticBrowseFetcher";
import { semanticBrowseFetch } from "./semanticBrowseFetcher";
import type * as Schemas from "./semanticBrowseSchemas";
import type * as Responses from "./semanticBrowseResponses";

export type LogoutError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type LogoutResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type LogoutVariables = SemanticBrowseContext["fetcherOptions"];

export const fetchLogout = (variables: LogoutVariables, signal?: AbortSignal) =>
  semanticBrowseFetch<LogoutResponse, LogoutError, undefined, {}, {}, {}>({
    url: "/users/logout",
    method: "post",
    ...variables,
    signal,
  });

export const useLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<LogoutResponse, LogoutError, LogoutVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<LogoutResponse, LogoutError, LogoutVariables>({
    mutationFn: (variables: LogoutVariables) =>
      fetchLogout({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type VerifyEmailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type VerifyEmailResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type VerifyEmailRequestBody = {
  token: string;
};

export type VerifyEmailVariables = {
  body: VerifyEmailRequestBody;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchVerifyEmail = (
  variables: VerifyEmailVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    VerifyEmailResponse,
    VerifyEmailError,
    VerifyEmailRequestBody,
    {},
    {},
    {}
  >({ url: "/users/verify-email", method: "post", ...variables, signal });

export const useVerifyEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      VerifyEmailResponse,
      VerifyEmailError,
      VerifyEmailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    VerifyEmailResponse,
    VerifyEmailError,
    VerifyEmailVariables
  >({
    mutationFn: (variables: VerifyEmailVariables) =>
      fetchVerifyEmail({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResendVerificationEmailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResendVerificationEmailResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type ResendVerificationEmailVariables =
  SemanticBrowseContext["fetcherOptions"];

export const fetchResendVerificationEmail = (
  variables: ResendVerificationEmailVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    ResendVerificationEmailResponse,
    ResendVerificationEmailError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/users/resend-verification-email",
    method: "post",
    ...variables,
    signal,
  });

export const useResendVerificationEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ResendVerificationEmailResponse,
      ResendVerificationEmailError,
      ResendVerificationEmailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    ResendVerificationEmailResponse,
    ResendVerificationEmailError,
    ResendVerificationEmailVariables
  >({
    mutationFn: (variables: ResendVerificationEmailVariables) =>
      fetchResendVerificationEmail({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResetPasswordRequestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResetPasswordRequestResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type ResetPasswordRequestRequestBody = {
  email: string;
};

export type ResetPasswordRequestVariables = {
  body: ResetPasswordRequestRequestBody;
} & SemanticBrowseContext["fetcherOptions"];

/**
 * A password reset link will be sent to the user's email if it exists. The response must always be success (even if email does not exist). This is to prevent email enumeration attacks.
 */
export const fetchResetPasswordRequest = (
  variables: ResetPasswordRequestVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    ResetPasswordRequestResponse,
    ResetPasswordRequestError,
    ResetPasswordRequestRequestBody,
    {},
    {},
    {}
  >({
    url: "/users/reset-password-request",
    method: "post",
    ...variables,
    signal,
  });

/**
 * A password reset link will be sent to the user's email if it exists. The response must always be success (even if email does not exist). This is to prevent email enumeration attacks.
 */
export const useResetPasswordRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ResetPasswordRequestResponse,
      ResetPasswordRequestError,
      ResetPasswordRequestVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    ResetPasswordRequestResponse,
    ResetPasswordRequestError,
    ResetPasswordRequestVariables
  >({
    mutationFn: (variables: ResetPasswordRequestVariables) =>
      fetchResetPasswordRequest({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResetPasswordError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResetPasswordResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type ResetPasswordRequestBody = {
  token: string;
  newPassword: string;
};

export type ResetPasswordVariables = {
  body: ResetPasswordRequestBody;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchResetPassword = (
  variables: ResetPasswordVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    ResetPasswordResponse,
    ResetPasswordError,
    ResetPasswordRequestBody,
    {},
    {},
    {}
  >({ url: "/users/reset-password", method: "post", ...variables, signal });

export const useResetPassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ResetPasswordResponse,
      ResetPasswordError,
      ResetPasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    ResetPasswordResponse,
    ResetPasswordError,
    ResetPasswordVariables
  >({
    mutationFn: (variables: ResetPasswordVariables) =>
      fetchResetPassword({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type SignupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SignupVariables = {
  body: Schemas.UserRegistration;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchSignup = (variables: SignupVariables, signal?: AbortSignal) =>
  semanticBrowseFetch<
    Responses.CreatedResponse,
    SignupError,
    Schemas.UserRegistration,
    {},
    {},
    {}
  >({ url: "/users/signup", method: "post", ...variables, signal });

export const useSignup = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.CreatedResponse,
      SignupError,
      SignupVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.CreatedResponse,
    SignupError,
    SignupVariables
  >({
    mutationFn: (variables: SignupVariables) =>
      fetchSignup({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LoginError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedResponse;
}>;

export type LoginResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.AuthToken;
};

export type LoginVariables = {
  body: Schemas.UserLogin;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) =>
  semanticBrowseFetch<LoginResponse, LoginError, Schemas.UserLogin, {}, {}, {}>(
    { url: "/users/login", method: "post", ...variables, signal },
  );

export const useLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<LoginResponse, LoginError, LoginVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<LoginResponse, LoginError, LoginVariables>({
    mutationFn: (variables: LoginVariables) =>
      fetchLogin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUserByIdPathParams = {
  userId: number;
};

export type GetUserByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetUserByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type GetUserByIdVariables = {
  pathParams: GetUserByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetUserById = (
  variables: GetUserByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetUserByIdResponse,
    GetUserByIdError,
    undefined,
    {},
    {},
    GetUserByIdPathParams
  >({ url: "/users/{userId}", method: "get", ...variables, signal });

export const useGetUserById = <TData = GetUserByIdResponse>(
  variables: GetUserByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetUserByIdResponse, GetUserByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<GetUserByIdResponse, GetUserByIdError, TData>({
    queryKey: queryKeyFn({
      path: "/users/{userId}",
      operationId: "getUserById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UpdateUserByIdPathParams = {
  userId: number;
};

export type UpdateUserByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type UpdateUserByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type UpdateUserByIdVariables = {
  body?: Schemas.UserProfile;
  pathParams: UpdateUserByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchUpdateUserById = (
  variables: UpdateUserByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    UpdateUserByIdResponse,
    UpdateUserByIdError,
    Schemas.UserProfile,
    {},
    {},
    UpdateUserByIdPathParams
  >({ url: "/users/{userId}", method: "put", ...variables, signal });

export const useUpdateUserById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UpdateUserByIdResponse,
      UpdateUserByIdError,
      UpdateUserByIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    UpdateUserByIdResponse,
    UpdateUserByIdError,
    UpdateUserByIdVariables
  >({
    mutationFn: (variables: UpdateUserByIdVariables) =>
      fetchUpdateUserById({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUserFollowingPathParams = {
  userId: number;
};

export type GetUserFollowingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetUserFollowingResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | Schemas.UserSummary[];
};

export type GetUserFollowingVariables = {
  pathParams: GetUserFollowingPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetUserFollowing = (
  variables: GetUserFollowingVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetUserFollowingResponse,
    GetUserFollowingError,
    undefined,
    {},
    {},
    GetUserFollowingPathParams
  >({ url: "/users/{userId}/following", method: "get", ...variables, signal });

export const useGetUserFollowing = <TData = GetUserFollowingResponse>(
  variables: GetUserFollowingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUserFollowingResponse,
      GetUserFollowingError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetUserFollowingResponse,
    GetUserFollowingError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}/following",
      operationId: "getUserFollowing",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserFollowing({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUserFollowersPathParams = {
  userId: number;
};

export type GetUserFollowersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetUserFollowersResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | Schemas.UserSummary[];
};

export type GetUserFollowersVariables = {
  pathParams: GetUserFollowersPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetUserFollowers = (
  variables: GetUserFollowersVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetUserFollowersResponse,
    GetUserFollowersError,
    undefined,
    {},
    {},
    GetUserFollowersPathParams
  >({ url: "/users/{userId}/followers", method: "get", ...variables, signal });

export const useGetUserFollowers = <TData = GetUserFollowersResponse>(
  variables: GetUserFollowersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUserFollowersResponse,
      GetUserFollowersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetUserFollowersResponse,
    GetUserFollowersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}/followers",
      operationId: "getUserFollowers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserFollowers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type FollowUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type FollowUserRequestBody = {
  followingUserId?: number;
};

export type FollowUserVariables = {
  body?: FollowUserRequestBody;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchFollowUser = (
  variables: FollowUserVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    Responses.OkResponse,
    FollowUserError,
    FollowUserRequestBody,
    {},
    {},
    {}
  >({ url: "/users/follow", method: "post", ...variables, signal });

export const useFollowUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.OkResponse,
      FollowUserError,
      FollowUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.OkResponse,
    FollowUserError,
    FollowUserVariables
  >({
    mutationFn: (variables: FollowUserVariables) =>
      fetchFollowUser({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UnfollowUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type UnfollowUserRequestBody = {
  followingUserId?: number;
};

export type UnfollowUserVariables = {
  body?: UnfollowUserRequestBody;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchUnfollowUser = (
  variables: UnfollowUserVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    Responses.OkResponse,
    UnfollowUserError,
    UnfollowUserRequestBody,
    {},
    {},
    {}
  >({ url: "/users/unfollow", method: "post", ...variables, signal });

export const useUnfollowUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.OkResponse,
      UnfollowUserError,
      UnfollowUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.OkResponse,
    UnfollowUserError,
    UnfollowUserVariables
  >({
    mutationFn: (variables: UnfollowUserVariables) =>
      fetchUnfollowUser({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type SearchUsersQueryParams = {
  q?: string;
};

export type SearchUsersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SearchUsersResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | Schemas.UserSummary[];
};

export type SearchUsersVariables = {
  queryParams?: SearchUsersQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchSearchUsers = (
  variables: SearchUsersVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    SearchUsersResponse,
    SearchUsersError,
    undefined,
    {},
    SearchUsersQueryParams,
    {}
  >({ url: "/search/users", method: "get", ...variables, signal });

export const useSearchUsers = <TData = SearchUsersResponse>(
  variables: SearchUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<SearchUsersResponse, SearchUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<SearchUsersResponse, SearchUsersError, TData>({
    queryKey: queryKeyFn({
      path: "/search/users",
      operationId: "searchUsers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchSearchUsers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type SearchDishesQueryParams = {
  q?: string;
  cuisine?: string;
  foodType?: string;
};

export type SearchDishesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SearchDishesResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | Schemas.DishDetails[];
};

export type SearchDishesVariables = {
  queryParams?: SearchDishesQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchSearchDishes = (
  variables: SearchDishesVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    SearchDishesResponse,
    SearchDishesError,
    undefined,
    {},
    SearchDishesQueryParams,
    {}
  >({ url: "/search/dishes", method: "get", ...variables, signal });

export const useSearchDishes = <TData = SearchDishesResponse>(
  variables: SearchDishesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<SearchDishesResponse, SearchDishesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<SearchDishesResponse, SearchDishesError, TData>({
    queryKey: queryKeyFn({
      path: "/search/dishes",
      operationId: "searchDishes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchSearchDishes({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetDishByIdPathParams = {
  dishId: number;
};

export type GetDishByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetDishByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.DishDetails;
};

export type GetDishByIdVariables = {
  pathParams: GetDishByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetDishById = (
  variables: GetDishByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetDishByIdResponse,
    GetDishByIdError,
    undefined,
    {},
    {},
    GetDishByIdPathParams
  >({ url: "/dishes/{dishId}", method: "get", ...variables, signal });

export const useGetDishById = <TData = GetDishByIdResponse>(
  variables: GetDishByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetDishByIdResponse, GetDishByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<GetDishByIdResponse, GetDishByIdError, TData>({
    queryKey: queryKeyFn({
      path: "/dishes/{dishId}",
      operationId: "getDishById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetDishById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetCuisineByIdPathParams = {
  cuisineId: number;
};

export type GetCuisineByIdQueryParams = {
  includeDishes?: boolean;
};

export type GetCuisineByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetCuisineByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.CuisineDetails;
};

export type GetCuisineByIdVariables = {
  pathParams: GetCuisineByIdPathParams;
  queryParams?: GetCuisineByIdQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetCuisineById = (
  variables: GetCuisineByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetCuisineByIdResponse,
    GetCuisineByIdError,
    undefined,
    {},
    GetCuisineByIdQueryParams,
    GetCuisineByIdPathParams
  >({ url: "/cuisines/{cuisineId}", method: "get", ...variables, signal });

export const useGetCuisineById = <TData = GetCuisineByIdResponse>(
  variables: GetCuisineByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCuisineByIdResponse,
      GetCuisineByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetCuisineByIdResponse,
    GetCuisineByIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cuisines/{cuisineId}",
      operationId: "getCuisineById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCuisineById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetRecipesForEntityQueryParams = {
  sort?: "recent" | "topRated";
  dishId?: number;
  cuisineId?: number;
};

export type GetRecipesForEntityError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetRecipesForEntityResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | Schemas.RecipeSummary[];
};

export type GetRecipesForEntityVariables = {
  queryParams?: GetRecipesForEntityQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetRecipesForEntity = (
  variables: GetRecipesForEntityVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetRecipesForEntityResponse,
    GetRecipesForEntityError,
    undefined,
    {},
    GetRecipesForEntityQueryParams,
    {}
  >({ url: "/recipes", method: "get", ...variables, signal });

export const useGetRecipesForEntity = <TData = GetRecipesForEntityResponse>(
  variables: GetRecipesForEntityVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetRecipesForEntityResponse,
      GetRecipesForEntityError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetRecipesForEntityResponse,
    GetRecipesForEntityError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/recipes",
      operationId: "getRecipesForEntity",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetRecipesForEntity({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type CreateRecipeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type CreateRecipeResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.RecipeDetails;
};

export type CreateRecipeVariables = {
  body: Schemas.NewRecipe;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchCreateRecipe = (
  variables: CreateRecipeVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    CreateRecipeResponse,
    CreateRecipeError,
    Schemas.NewRecipe,
    {},
    {},
    {}
  >({ url: "/recipes", method: "post", ...variables, signal });

export const useCreateRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      CreateRecipeResponse,
      CreateRecipeError,
      CreateRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    CreateRecipeResponse,
    CreateRecipeError,
    CreateRecipeVariables
  >({
    mutationFn: (variables: CreateRecipeVariables) =>
      fetchCreateRecipe({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetRecipeByIdPathParams = {
  recipeId: number;
};

export type GetRecipeByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetRecipeByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.RecipeDetails;
};

export type GetRecipeByIdVariables = {
  pathParams: GetRecipeByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetRecipeById = (
  variables: GetRecipeByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetRecipeByIdResponse,
    GetRecipeByIdError,
    undefined,
    {},
    {},
    GetRecipeByIdPathParams
  >({ url: "/recipes/{recipeId}", method: "get", ...variables, signal });

export const useGetRecipeById = <TData = GetRecipeByIdResponse>(
  variables: GetRecipeByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetRecipeByIdResponse,
      GetRecipeByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<GetRecipeByIdResponse, GetRecipeByIdError, TData>({
    queryKey: queryKeyFn({
      path: "/recipes/{recipeId}",
      operationId: "getRecipeById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetRecipeById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type DeleteRecipeByIdPathParams = {
  recipeId: number;
};

export type DeleteRecipeByIdError = Fetcher.ErrorWrapper<
  | {
      status: 403;
      payload: Responses.ForbiddenResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type DeleteRecipeByIdVariables = {
  pathParams: DeleteRecipeByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchDeleteRecipeById = (
  variables: DeleteRecipeByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    Responses.OkResponse,
    DeleteRecipeByIdError,
    undefined,
    {},
    {},
    DeleteRecipeByIdPathParams
  >({ url: "/recipes/{recipeId}", method: "delete", ...variables, signal });

export const useDeleteRecipeById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.OkResponse,
      DeleteRecipeByIdError,
      DeleteRecipeByIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.OkResponse,
    DeleteRecipeByIdError,
    DeleteRecipeByIdVariables
  >({
    mutationFn: (variables: DeleteRecipeByIdVariables) =>
      fetchDeleteRecipeById({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RateRecipePathParams = {
  recipeId: number;
};

export type RateRecipeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type RateRecipeRequestBody = {
  /**
   * @minimum 1
   * @maximum 5
   */
  rating?: number;
};

export type RateRecipeVariables = {
  body?: RateRecipeRequestBody;
  pathParams: RateRecipePathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchRateRecipe = (
  variables: RateRecipeVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    Responses.OkResponse,
    RateRecipeError,
    RateRecipeRequestBody,
    {},
    {},
    RateRecipePathParams
  >({
    url: "/recipes/{recipeId}/rating",
    method: "post",
    ...variables,
    signal,
  });

export const useRateRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.OkResponse,
      RateRecipeError,
      RateRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.OkResponse,
    RateRecipeError,
    RateRecipeVariables
  >({
    mutationFn: (variables: RateRecipeVariables) =>
      fetchRateRecipe({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type BookmarkRecipePathParams = {
  recipeId: number;
};

export type BookmarkRecipeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type BookmarkRecipeVariables = {
  pathParams: BookmarkRecipePathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchBookmarkRecipe = (
  variables: BookmarkRecipeVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    Responses.OkResponse,
    BookmarkRecipeError,
    undefined,
    {},
    {},
    BookmarkRecipePathParams
  >({
    url: "/recipes/{recipeId}/bookmark",
    method: "post",
    ...variables,
    signal,
  });

export const useBookmarkRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.OkResponse,
      BookmarkRecipeError,
      BookmarkRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.OkResponse,
    BookmarkRecipeError,
    BookmarkRecipeVariables
  >({
    mutationFn: (variables: BookmarkRecipeVariables) =>
      fetchBookmarkRecipe({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetFeedQueryParams = {
  type: "explore" | "following";
};

export type GetFeedError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetFeedResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritive the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | Schemas.RecipeSummary[];
};

export type GetFeedVariables = {
  queryParams: GetFeedQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetFeed = (
  variables: GetFeedVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetFeedResponse,
    GetFeedError,
    undefined,
    {},
    GetFeedQueryParams,
    {}
  >({ url: "/feed", method: "get", ...variables, signal });

export const useGetFeed = <TData = GetFeedResponse>(
  variables: GetFeedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetFeedResponse, GetFeedError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<GetFeedResponse, GetFeedError, TData>({
    queryKey: queryKeyFn({ path: "/feed", operationId: "getFeed", variables }),
    queryFn: ({ signal }) =>
      fetchGetFeed({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/users/{userId}";
      operationId: "getUserById";
      variables: GetUserByIdVariables;
    }
  | {
      path: "/users/{userId}/following";
      operationId: "getUserFollowing";
      variables: GetUserFollowingVariables;
    }
  | {
      path: "/users/{userId}/followers";
      operationId: "getUserFollowers";
      variables: GetUserFollowersVariables;
    }
  | {
      path: "/search/users";
      operationId: "searchUsers";
      variables: SearchUsersVariables;
    }
  | {
      path: "/search/dishes";
      operationId: "searchDishes";
      variables: SearchDishesVariables;
    }
  | {
      path: "/dishes/{dishId}";
      operationId: "getDishById";
      variables: GetDishByIdVariables;
    }
  | {
      path: "/cuisines/{cuisineId}";
      operationId: "getCuisineById";
      variables: GetCuisineByIdVariables;
    }
  | {
      path: "/recipes";
      operationId: "getRecipesForEntity";
      variables: GetRecipesForEntityVariables;
    }
  | {
      path: "/recipes/{recipeId}";
      operationId: "getRecipeById";
      variables: GetRecipeByIdVariables;
    }
  | {
      path: "/feed";
      operationId: "getFeed";
      variables: GetFeedVariables;
    };
