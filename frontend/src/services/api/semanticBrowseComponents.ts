/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.3
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useSemanticBrowseContext,
  SemanticBrowseContext,
} from "./semanticBrowseContext";
import type * as Fetcher from "./semanticBrowseFetcher";
import { semanticBrowseFetch } from "./semanticBrowseFetcher";
import type * as Schemas from "./semanticBrowseSchemas";
import type * as Responses from "./semanticBrowseResponses";

export type LogoutError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type LogoutResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type LogoutVariables = SemanticBrowseContext["fetcherOptions"];

export const fetchLogout = (variables: LogoutVariables, signal?: AbortSignal) =>
  semanticBrowseFetch<LogoutResponse, LogoutError, undefined, {}, {}, {}>({
    url: "/users/logout",
    method: "post",
    ...variables,
    signal,
  });

export const useLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<LogoutResponse, LogoutError, LogoutVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<LogoutResponse, LogoutError, LogoutVariables>({
    mutationFn: (variables: LogoutVariables) =>
      fetchLogout({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type VerifyEmailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type VerifyEmailResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type VerifyEmailRequestBody = {
  token: string;
};

export type VerifyEmailVariables = {
  body: VerifyEmailRequestBody;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchVerifyEmail = (
  variables: VerifyEmailVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    VerifyEmailResponse,
    VerifyEmailError,
    VerifyEmailRequestBody,
    {},
    {},
    {}
  >({ url: "/users/verify-email", method: "post", ...variables, signal });

export const useVerifyEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      VerifyEmailResponse,
      VerifyEmailError,
      VerifyEmailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    VerifyEmailResponse,
    VerifyEmailError,
    VerifyEmailVariables
  >({
    mutationFn: (variables: VerifyEmailVariables) =>
      fetchVerifyEmail({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResendVerificationEmailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResendVerificationEmailResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type ResendVerificationEmailVariables =
  SemanticBrowseContext["fetcherOptions"];

export const fetchResendVerificationEmail = (
  variables: ResendVerificationEmailVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    ResendVerificationEmailResponse,
    ResendVerificationEmailError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/users/resend-verification-email",
    method: "post",
    ...variables,
    signal,
  });

export const useResendVerificationEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ResendVerificationEmailResponse,
      ResendVerificationEmailError,
      ResendVerificationEmailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    ResendVerificationEmailResponse,
    ResendVerificationEmailError,
    ResendVerificationEmailVariables
  >({
    mutationFn: (variables: ResendVerificationEmailVariables) =>
      fetchResendVerificationEmail({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResetPasswordRequestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResetPasswordRequestResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type ResetPasswordRequestRequestBody = {
  email: string;
};

export type ResetPasswordRequestVariables = {
  body: ResetPasswordRequestRequestBody;
} & SemanticBrowseContext["fetcherOptions"];

/**
 * A password reset link will be sent to the user's email if it exists. The response must always be success (even if email does not exist). This is to prevent email enumeration attacks.
 */
export const fetchResetPasswordRequest = (
  variables: ResetPasswordRequestVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    ResetPasswordRequestResponse,
    ResetPasswordRequestError,
    ResetPasswordRequestRequestBody,
    {},
    {},
    {}
  >({
    url: "/users/reset-password-request",
    method: "post",
    ...variables,
    signal,
  });

/**
 * A password reset link will be sent to the user's email if it exists. The response must always be success (even if email does not exist). This is to prevent email enumeration attacks.
 */
export const useResetPasswordRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ResetPasswordRequestResponse,
      ResetPasswordRequestError,
      ResetPasswordRequestVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    ResetPasswordRequestResponse,
    ResetPasswordRequestError,
    ResetPasswordRequestVariables
  >({
    mutationFn: (variables: ResetPasswordRequestVariables) =>
      fetchResetPasswordRequest({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResetPasswordError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResetPasswordResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type ResetPasswordRequestBody = {
  token: string;
  newPassword: string;
};

export type ResetPasswordVariables = {
  body: ResetPasswordRequestBody;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchResetPassword = (
  variables: ResetPasswordVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    ResetPasswordResponse,
    ResetPasswordError,
    ResetPasswordRequestBody,
    {},
    {},
    {}
  >({ url: "/users/reset-password", method: "post", ...variables, signal });

export const useResetPassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ResetPasswordResponse,
      ResetPasswordError,
      ResetPasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    ResetPasswordResponse,
    ResetPasswordError,
    ResetPasswordVariables
  >({
    mutationFn: (variables: ResetPasswordVariables) =>
      fetchResetPassword({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type SignupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SignupVariables = {
  body: Schemas.UserRegistration;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchSignup = (variables: SignupVariables, signal?: AbortSignal) =>
  semanticBrowseFetch<
    Responses.CreatedResponse,
    SignupError,
    Schemas.UserRegistration,
    {},
    {},
    {}
  >({ url: "/users/signup", method: "post", ...variables, signal });

export const useSignup = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.CreatedResponse,
      SignupError,
      SignupVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.CreatedResponse,
    SignupError,
    SignupVariables
  >({
    mutationFn: (variables: SignupVariables) =>
      fetchSignup({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LoginError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedResponse;
}>;

export type LoginResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.AuthToken;
};

export type LoginVariables = {
  body: Schemas.UserLogin;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) =>
  semanticBrowseFetch<LoginResponse, LoginError, Schemas.UserLogin, {}, {}, {}>(
    { url: "/users/login", method: "post", ...variables, signal },
  );

export const useLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<LoginResponse, LoginError, LoginVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<LoginResponse, LoginError, LoginVariables>({
    mutationFn: (variables: LoginVariables) =>
      fetchLogin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUserByIdPathParams = {
  userId: number;
};

export type GetUserByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetUserByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type GetUserByIdVariables = {
  pathParams: GetUserByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetUserById = (
  variables: GetUserByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetUserByIdResponse,
    GetUserByIdError,
    undefined,
    {},
    {},
    GetUserByIdPathParams
  >({ url: "/users/{userId}", method: "get", ...variables, signal });

export const useGetUserById = <TData = GetUserByIdResponse>(
  variables: GetUserByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetUserByIdResponse, GetUserByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<GetUserByIdResponse, GetUserByIdError, TData>({
    queryKey: queryKeyFn({
      path: "/users/{userId}",
      operationId: "getUserById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UpdateUserByIdPathParams = {
  userId: number;
};

export type UpdateUserByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type UpdateUserByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type UpdateUserByIdVariables = {
  body?: Schemas.UserProfile;
  pathParams: UpdateUserByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

/**
 * Can only update own profile
 */
export const fetchUpdateUserById = (
  variables: UpdateUserByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    UpdateUserByIdResponse,
    UpdateUserByIdError,
    Schemas.UserProfile,
    {},
    {},
    UpdateUserByIdPathParams
  >({ url: "/users/{userId}", method: "put", ...variables, signal });

/**
 * Can only update own profile
 */
export const useUpdateUserById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UpdateUserByIdResponse,
      UpdateUserByIdError,
      UpdateUserByIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    UpdateUserByIdResponse,
    UpdateUserByIdError,
    UpdateUserByIdVariables
  >({
    mutationFn: (variables: UpdateUserByIdVariables) =>
      fetchUpdateUserById({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetMeError = Fetcher.ErrorWrapper<{
  status: 403;
  payload: Responses.ForbiddenResponse;
}>;

export type GetMeResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type GetMeVariables = SemanticBrowseContext["fetcherOptions"];

export const fetchGetMe = (variables: GetMeVariables, signal?: AbortSignal) =>
  semanticBrowseFetch<GetMeResponse, GetMeError, undefined, {}, {}, {}>({
    url: "/users/me",
    method: "get",
    ...variables,
    signal,
  });

export const useGetMe = <TData = GetMeResponse>(
  variables: GetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetMeResponse, GetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<GetMeResponse, GetMeError, TData>({
    queryKey: queryKeyFn({
      path: "/users/me",
      operationId: "getMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUserFollowingPathParams = {
  userId: number;
};

export type GetUserFollowingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetUserFollowingResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserArray;
};

export type GetUserFollowingVariables = {
  pathParams: GetUserFollowingPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetUserFollowing = (
  variables: GetUserFollowingVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetUserFollowingResponse,
    GetUserFollowingError,
    undefined,
    {},
    {},
    GetUserFollowingPathParams
  >({ url: "/users/{userId}/following", method: "get", ...variables, signal });

export const useGetUserFollowing = <TData = GetUserFollowingResponse>(
  variables: GetUserFollowingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUserFollowingResponse,
      GetUserFollowingError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetUserFollowingResponse,
    GetUserFollowingError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}/following",
      operationId: "getUserFollowing",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserFollowing({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUserFollowersPathParams = {
  userId: number;
};

export type GetUserFollowersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetUserFollowersResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserArray;
};

export type GetUserFollowersVariables = {
  pathParams: GetUserFollowersPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetUserFollowers = (
  variables: GetUserFollowersVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetUserFollowersResponse,
    GetUserFollowersError,
    undefined,
    {},
    {},
    GetUserFollowersPathParams
  >({ url: "/users/{userId}/followers", method: "get", ...variables, signal });

export const useGetUserFollowers = <TData = GetUserFollowersResponse>(
  variables: GetUserFollowersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUserFollowersResponse,
      GetUserFollowersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetUserFollowersResponse,
    GetUserFollowersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}/followers",
      operationId: "getUserFollowers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserFollowers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type FollowUserPathParams = {
  userId: number;
};

export type FollowUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type FollowUserResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type FollowUserVariables = {
  pathParams: FollowUserPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchFollowUser = (
  variables: FollowUserVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    FollowUserResponse,
    FollowUserError,
    undefined,
    {},
    {},
    FollowUserPathParams
  >({ url: "/users/{userId}/follow", method: "post", ...variables, signal });

export const useFollowUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      FollowUserResponse,
      FollowUserError,
      FollowUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    FollowUserResponse,
    FollowUserError,
    FollowUserVariables
  >({
    mutationFn: (variables: FollowUserVariables) =>
      fetchFollowUser({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UnfollowUserPathParams = {
  userId: number;
};

export type UnfollowUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type UnfollowUserResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type UnfollowUserVariables = {
  pathParams: UnfollowUserPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchUnfollowUser = (
  variables: UnfollowUserVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    UnfollowUserResponse,
    UnfollowUserError,
    undefined,
    {},
    {},
    UnfollowUserPathParams
  >({ url: "/users/{userId}/follow", method: "delete", ...variables, signal });

export const useUnfollowUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UnfollowUserResponse,
      UnfollowUserError,
      UnfollowUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    UnfollowUserResponse,
    UnfollowUserError,
    UnfollowUserVariables
  >({
    mutationFn: (variables: UnfollowUserVariables) =>
      fetchUnfollowUser({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type SearchUsersQueryParams = {
  q?: string;
};

export type SearchUsersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SearchUsersResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserArray;
};

export type SearchUsersVariables = {
  queryParams?: SearchUsersQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchSearchUsers = (
  variables: SearchUsersVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    SearchUsersResponse,
    SearchUsersError,
    undefined,
    {},
    SearchUsersQueryParams,
    {}
  >({ url: "/search/users", method: "get", ...variables, signal });

export const useSearchUsers = <TData = SearchUsersResponse>(
  variables: SearchUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<SearchUsersResponse, SearchUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<SearchUsersResponse, SearchUsersError, TData>({
    queryKey: queryKeyFn({
      path: "/search/users",
      operationId: "searchUsers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchSearchUsers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type SearchDishesQueryParams = {
  q?: string;
  cuisine?: string;
  foodType?: string;
};

export type SearchDishesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SearchDishesResponse = {
  data: Schemas.DishArray;
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
};

export type SearchDishesVariables = {
  queryParams?: SearchDishesQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchSearchDishes = (
  variables: SearchDishesVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    SearchDishesResponse,
    SearchDishesError,
    undefined,
    {},
    SearchDishesQueryParams,
    {}
  >({ url: "/search/dishes", method: "get", ...variables, signal });

export const useSearchDishes = <TData = SearchDishesResponse>(
  variables: SearchDishesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<SearchDishesResponse, SearchDishesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<SearchDishesResponse, SearchDishesError, TData>({
    queryKey: queryKeyFn({
      path: "/search/dishes",
      operationId: "searchDishes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchSearchDishes({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetDishByIdPathParams = {
  dishId: number;
};

export type GetDishByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetDishByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.DishDetails;
};

export type GetDishByIdVariables = {
  pathParams: GetDishByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetDishById = (
  variables: GetDishByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetDishByIdResponse,
    GetDishByIdError,
    undefined,
    {},
    {},
    GetDishByIdPathParams
  >({ url: "/dishes/{dishId}", method: "get", ...variables, signal });

export const useGetDishById = <TData = GetDishByIdResponse>(
  variables: GetDishByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetDishByIdResponse, GetDishByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<GetDishByIdResponse, GetDishByIdError, TData>({
    queryKey: queryKeyFn({
      path: "/dishes/{dishId}",
      operationId: "getDishById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetDishById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetCuisineByIdPathParams = {
  cuisineId: number;
};

export type GetCuisineByIdQueryParams = {
  includeDishes?: boolean;
};

export type GetCuisineByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetCuisineByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.CuisineDetails;
};

export type GetCuisineByIdVariables = {
  pathParams: GetCuisineByIdPathParams;
  queryParams?: GetCuisineByIdQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetCuisineById = (
  variables: GetCuisineByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetCuisineByIdResponse,
    GetCuisineByIdError,
    undefined,
    {},
    GetCuisineByIdQueryParams,
    GetCuisineByIdPathParams
  >({ url: "/cuisines/{cuisineId}", method: "get", ...variables, signal });

export const useGetCuisineById = <TData = GetCuisineByIdResponse>(
  variables: GetCuisineByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCuisineByIdResponse,
      GetCuisineByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetCuisineByIdResponse,
    GetCuisineByIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/cuisines/{cuisineId}",
      operationId: "getCuisineById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCuisineById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type FollowCuisinePathParams = {
  cuisineId: number;
};

export type FollowCuisineError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type FollowCuisineResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.CuisineDetails;
};

export type FollowCuisineVariables = {
  pathParams: FollowCuisinePathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchFollowCuisine = (
  variables: FollowCuisineVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    FollowCuisineResponse,
    FollowCuisineError,
    undefined,
    {},
    {},
    FollowCuisinePathParams
  >({
    url: "/cuisines/{cuisineId}/follow",
    method: "post",
    ...variables,
    signal,
  });

export const useFollowCuisine = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      FollowCuisineResponse,
      FollowCuisineError,
      FollowCuisineVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    FollowCuisineResponse,
    FollowCuisineError,
    FollowCuisineVariables
  >({
    mutationFn: (variables: FollowCuisineVariables) =>
      fetchFollowCuisine({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetRecipesForEntityQueryParams = {
  sort?: "recent" | "topRated";
  dishId?: number;
  cuisineId?: number;
};

export type GetRecipesForEntityError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetRecipesForEntityResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.RecipeArray;
};

export type GetRecipesForEntityVariables = {
  queryParams?: GetRecipesForEntityQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetRecipesForEntity = (
  variables: GetRecipesForEntityVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetRecipesForEntityResponse,
    GetRecipesForEntityError,
    undefined,
    {},
    GetRecipesForEntityQueryParams,
    {}
  >({ url: "/recipes", method: "get", ...variables, signal });

export const useGetRecipesForEntity = <TData = GetRecipesForEntityResponse>(
  variables: GetRecipesForEntityVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetRecipesForEntityResponse,
      GetRecipesForEntityError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetRecipesForEntityResponse,
    GetRecipesForEntityError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/recipes",
      operationId: "getRecipesForEntity",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetRecipesForEntity({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type CreateRecipeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type CreateRecipeResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.RecipeDetails;
};

export type CreateRecipeVariables = {
  body: Schemas.NewRecipe;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchCreateRecipe = (
  variables: CreateRecipeVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    CreateRecipeResponse,
    CreateRecipeError,
    Schemas.NewRecipe,
    {},
    {},
    {}
  >({ url: "/recipes", method: "post", ...variables, signal });

export const useCreateRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      CreateRecipeResponse,
      CreateRecipeError,
      CreateRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    CreateRecipeResponse,
    CreateRecipeError,
    CreateRecipeVariables
  >({
    mutationFn: (variables: CreateRecipeVariables) =>
      fetchCreateRecipe({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetRecipeByIdPathParams = {
  recipeId: number;
};

export type GetRecipeByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetRecipeByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.RecipeDetails;
};

export type GetRecipeByIdVariables = {
  pathParams: GetRecipeByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetRecipeById = (
  variables: GetRecipeByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetRecipeByIdResponse,
    GetRecipeByIdError,
    undefined,
    {},
    {},
    GetRecipeByIdPathParams
  >({ url: "/recipes/{recipeId}", method: "get", ...variables, signal });

export const useGetRecipeById = <TData = GetRecipeByIdResponse>(
  variables: GetRecipeByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetRecipeByIdResponse,
      GetRecipeByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<GetRecipeByIdResponse, GetRecipeByIdError, TData>({
    queryKey: queryKeyFn({
      path: "/recipes/{recipeId}",
      operationId: "getRecipeById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetRecipeById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type DeleteRecipeByIdPathParams = {
  recipeId: number;
};

export type DeleteRecipeByIdError = Fetcher.ErrorWrapper<
  | {
      status: 403;
      payload: Responses.ForbiddenResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type DeleteRecipeByIdVariables = {
  pathParams: DeleteRecipeByIdPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchDeleteRecipeById = (
  variables: DeleteRecipeByIdVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    Responses.OkResponse,
    DeleteRecipeByIdError,
    undefined,
    {},
    {},
    DeleteRecipeByIdPathParams
  >({ url: "/recipes/{recipeId}", method: "delete", ...variables, signal });

export const useDeleteRecipeById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.OkResponse,
      DeleteRecipeByIdError,
      DeleteRecipeByIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.OkResponse,
    DeleteRecipeByIdError,
    DeleteRecipeByIdVariables
  >({
    mutationFn: (variables: DeleteRecipeByIdVariables) =>
      fetchDeleteRecipeById({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RateRecipePathParams = {
  recipeId: number;
};

export type RateRecipeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type RateRecipeRequestBody = {
  /**
   * @minimum 1
   * @maximum 5
   */
  rating?: number;
};

export type RateRecipeVariables = {
  body?: RateRecipeRequestBody;
  pathParams: RateRecipePathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchRateRecipe = (
  variables: RateRecipeVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    Responses.OkResponse,
    RateRecipeError,
    RateRecipeRequestBody,
    {},
    {},
    RateRecipePathParams
  >({
    url: "/recipes/{recipeId}/rating",
    method: "post",
    ...variables,
    signal,
  });

export const useRateRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.OkResponse,
      RateRecipeError,
      RateRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.OkResponse,
    RateRecipeError,
    RateRecipeVariables
  >({
    mutationFn: (variables: RateRecipeVariables) =>
      fetchRateRecipe({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetBookmarkersPathParams = {
  recipeId: number;
};

export type GetBookmarkersError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetBookmarkersResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserArray;
};

export type GetBookmarkersVariables = {
  pathParams: GetBookmarkersPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetBookmarkers = (
  variables: GetBookmarkersVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetBookmarkersResponse,
    GetBookmarkersError,
    undefined,
    {},
    {},
    GetBookmarkersPathParams
  >({
    url: "/recipes/{recipeId}/bookmarks",
    method: "get",
    ...variables,
    signal,
  });

export const useGetBookmarkers = <TData = GetBookmarkersResponse>(
  variables: GetBookmarkersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookmarkersResponse,
      GetBookmarkersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetBookmarkersResponse,
    GetBookmarkersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/recipes/{recipeId}/bookmarks",
      operationId: "getBookmarkers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBookmarkers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type BookmarkRecipePathParams = {
  recipeId: number;
};

export type BookmarkRecipeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type BookmarkRecipeVariables = {
  pathParams: BookmarkRecipePathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchBookmarkRecipe = (
  variables: BookmarkRecipeVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    Responses.OkResponse,
    BookmarkRecipeError,
    undefined,
    {},
    {},
    BookmarkRecipePathParams
  >({
    url: "/recipes/{recipeId}/bookmarks",
    method: "post",
    ...variables,
    signal,
  });

export const useBookmarkRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.OkResponse,
      BookmarkRecipeError,
      BookmarkRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.OkResponse,
    BookmarkRecipeError,
    BookmarkRecipeVariables
  >({
    mutationFn: (variables: BookmarkRecipeVariables) =>
      fetchBookmarkRecipe({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UnbookmarkRecipePathParams = {
  recipeId: number;
};

export type UnbookmarkRecipeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type UnbookmarkRecipeVariables = {
  pathParams: UnbookmarkRecipePathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchUnbookmarkRecipe = (
  variables: UnbookmarkRecipeVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    Responses.OkResponse,
    UnbookmarkRecipeError,
    undefined,
    {},
    {},
    UnbookmarkRecipePathParams
  >({
    url: "/recipes/{recipeId}/bookmarks",
    method: "delete",
    ...variables,
    signal,
  });

export const useUnbookmarkRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.OkResponse,
      UnbookmarkRecipeError,
      UnbookmarkRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    Responses.OkResponse,
    UnbookmarkRecipeError,
    UnbookmarkRecipeVariables
  >({
    mutationFn: (variables: UnbookmarkRecipeVariables) =>
      fetchUnbookmarkRecipe({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCommentsForRecipePathParams = {
  recipeId: number;
};

export type GetCommentsForRecipeError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetCommentsForRecipeResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.CommentArray;
};

export type GetCommentsForRecipeVariables = {
  pathParams: GetCommentsForRecipePathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetCommentsForRecipe = (
  variables: GetCommentsForRecipeVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetCommentsForRecipeResponse,
    GetCommentsForRecipeError,
    undefined,
    {},
    {},
    GetCommentsForRecipePathParams
  >({
    url: "/recipes/{recipeId}/comments",
    method: "get",
    ...variables,
    signal,
  });

export const useGetCommentsForRecipe = <TData = GetCommentsForRecipeResponse>(
  variables: GetCommentsForRecipeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCommentsForRecipeResponse,
      GetCommentsForRecipeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<
    GetCommentsForRecipeResponse,
    GetCommentsForRecipeError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/recipes/{recipeId}/comments",
      operationId: "getCommentsForRecipe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCommentsForRecipe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type AddCommentToRecipePathParams = {
  recipeId: number;
};

export type AddCommentToRecipeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type AddCommentToRecipeResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.Comment;
};

export type AddCommentToRecipeRequestBody = {
  comment?: string;
};

export type AddCommentToRecipeVariables = {
  body?: AddCommentToRecipeRequestBody;
  pathParams: AddCommentToRecipePathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchAddCommentToRecipe = (
  variables: AddCommentToRecipeVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    AddCommentToRecipeResponse,
    AddCommentToRecipeError,
    AddCommentToRecipeRequestBody,
    {},
    {},
    AddCommentToRecipePathParams
  >({
    url: "/recipes/{recipeId}/comments",
    method: "post",
    ...variables,
    signal,
  });

export const useAddCommentToRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AddCommentToRecipeResponse,
      AddCommentToRecipeError,
      AddCommentToRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    AddCommentToRecipeResponse,
    AddCommentToRecipeError,
    AddCommentToRecipeVariables
  >({
    mutationFn: (variables: AddCommentToRecipeVariables) =>
      fetchAddCommentToRecipe({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UpvoteCommentPathParams = {
  recipeId: number;
  commentId: number;
};

export type UpvoteCommentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type UpvoteCommentResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.Comment;
};

export type UpvoteCommentVariables = {
  pathParams: UpvoteCommentPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchUpvoteComment = (
  variables: UpvoteCommentVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    UpvoteCommentResponse,
    UpvoteCommentError,
    undefined,
    {},
    {},
    UpvoteCommentPathParams
  >({
    url: "/recipes/{recipeId}/comments/{commentId}/upvote",
    method: "post",
    ...variables,
    signal,
  });

export const useUpvoteComment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UpvoteCommentResponse,
      UpvoteCommentError,
      UpvoteCommentVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    UpvoteCommentResponse,
    UpvoteCommentError,
    UpvoteCommentVariables
  >({
    mutationFn: (variables: UpvoteCommentVariables) =>
      fetchUpvoteComment({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RemoveUpvoteFromCommentPathParams = {
  recipeId: number;
  commentId: number;
};

export type RemoveUpvoteFromCommentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type RemoveUpvoteFromCommentResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.Comment;
};

export type RemoveUpvoteFromCommentVariables = {
  pathParams: RemoveUpvoteFromCommentPathParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchRemoveUpvoteFromComment = (
  variables: RemoveUpvoteFromCommentVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    RemoveUpvoteFromCommentResponse,
    RemoveUpvoteFromCommentError,
    undefined,
    {},
    {},
    RemoveUpvoteFromCommentPathParams
  >({
    url: "/recipes/{recipeId}/comments/{commentId}/upvote",
    method: "delete",
    ...variables,
    signal,
  });

export const useRemoveUpvoteFromComment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      RemoveUpvoteFromCommentResponse,
      RemoveUpvoteFromCommentError,
      RemoveUpvoteFromCommentVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSemanticBrowseContext();
  return reactQuery.useMutation<
    RemoveUpvoteFromCommentResponse,
    RemoveUpvoteFromCommentError,
    RemoveUpvoteFromCommentVariables
  >({
    mutationFn: (variables: RemoveUpvoteFromCommentVariables) =>
      fetchRemoveUpvoteFromComment({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetFeedQueryParams = {
  type: "explore" | "following";
};

export type GetFeedError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetFeedResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.RecipeArray;
};

export type GetFeedVariables = {
  queryParams: GetFeedQueryParams;
} & SemanticBrowseContext["fetcherOptions"];

export const fetchGetFeed = (
  variables: GetFeedVariables,
  signal?: AbortSignal,
) =>
  semanticBrowseFetch<
    GetFeedResponse,
    GetFeedError,
    undefined,
    {},
    GetFeedQueryParams,
    {}
  >({ url: "/feed", method: "get", ...variables, signal });

export const useGetFeed = <TData = GetFeedResponse>(
  variables: GetFeedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetFeedResponse, GetFeedError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSemanticBrowseContext(options);
  return reactQuery.useQuery<GetFeedResponse, GetFeedError, TData>({
    queryKey: queryKeyFn({ path: "/feed", operationId: "getFeed", variables }),
    queryFn: ({ signal }) =>
      fetchGetFeed({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/users/{userId}";
      operationId: "getUserById";
      variables: GetUserByIdVariables;
    }
  | {
      path: "/users/me";
      operationId: "getMe";
      variables: GetMeVariables;
    }
  | {
      path: "/users/{userId}/following";
      operationId: "getUserFollowing";
      variables: GetUserFollowingVariables;
    }
  | {
      path: "/users/{userId}/followers";
      operationId: "getUserFollowers";
      variables: GetUserFollowersVariables;
    }
  | {
      path: "/search/users";
      operationId: "searchUsers";
      variables: SearchUsersVariables;
    }
  | {
      path: "/search/dishes";
      operationId: "searchDishes";
      variables: SearchDishesVariables;
    }
  | {
      path: "/dishes/{dishId}";
      operationId: "getDishById";
      variables: GetDishByIdVariables;
    }
  | {
      path: "/cuisines/{cuisineId}";
      operationId: "getCuisineById";
      variables: GetCuisineByIdVariables;
    }
  | {
      path: "/recipes";
      operationId: "getRecipesForEntity";
      variables: GetRecipesForEntityVariables;
    }
  | {
      path: "/recipes/{recipeId}";
      operationId: "getRecipeById";
      variables: GetRecipeByIdVariables;
    }
  | {
      path: "/recipes/{recipeId}/bookmarks";
      operationId: "getBookmarkers";
      variables: GetBookmarkersVariables;
    }
  | {
      path: "/recipes/{recipeId}/comments";
      operationId: "getCommentsForRecipe";
      variables: GetCommentsForRecipeVariables;
    }
  | {
      path: "/feed";
      operationId: "getFeed";
      variables: GetFeedVariables;
    };
