/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useProgrammingForumContext,
  ProgrammingForumContext,
} from "./programmingForumContext";
import type * as Fetcher from "./programmingForumFetcher";
import { programmingForumFetch } from "./programmingForumFetcher";
import type * as Schemas from "./programmingForumSchemas";
import type * as Responses from "./programmingForumResponses";

export type LogoutError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type LogoutResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type LogoutVariables = ProgrammingForumContext["fetcherOptions"];

export const fetchLogout = (variables: LogoutVariables, signal?: AbortSignal) =>
  programmingForumFetch<LogoutResponse, LogoutError, undefined, {}, {}, {}>({
    url: "/users/logout",
    method: "post",
    ...variables,
    signal,
  });

export const useLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<LogoutResponse, LogoutError, LogoutVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<LogoutResponse, LogoutError, LogoutVariables>({
    mutationFn: (variables: LogoutVariables) =>
      fetchLogout({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type VerifyEmailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type VerifyEmailResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type VerifyEmailRequestBody = {
  token: string;
};

export type VerifyEmailVariables = {
  body: VerifyEmailRequestBody;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchVerifyEmail = (
  variables: VerifyEmailVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    VerifyEmailResponse,
    VerifyEmailError,
    VerifyEmailRequestBody,
    {},
    {},
    {}
  >({ url: "/users/verify-email", method: "post", ...variables, signal });

export const useVerifyEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      VerifyEmailResponse,
      VerifyEmailError,
      VerifyEmailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    VerifyEmailResponse,
    VerifyEmailError,
    VerifyEmailVariables
  >({
    mutationFn: (variables: VerifyEmailVariables) =>
      fetchVerifyEmail({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResendVerificationEmailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResendVerificationEmailResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type ResendVerificationEmailVariables =
  ProgrammingForumContext["fetcherOptions"];

export const fetchResendVerificationEmail = (
  variables: ResendVerificationEmailVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    ResendVerificationEmailResponse,
    ResendVerificationEmailError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/users/resend-verification-email",
    method: "post",
    ...variables,
    signal,
  });

export const useResendVerificationEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ResendVerificationEmailResponse,
      ResendVerificationEmailError,
      ResendVerificationEmailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    ResendVerificationEmailResponse,
    ResendVerificationEmailError,
    ResendVerificationEmailVariables
  >({
    mutationFn: (variables: ResendVerificationEmailVariables) =>
      fetchResendVerificationEmail({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResetPasswordRequestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResetPasswordRequestResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type ResetPasswordRequestRequestBody = {
  email: string;
};

export type ResetPasswordRequestVariables = {
  body: ResetPasswordRequestRequestBody;
} & ProgrammingForumContext["fetcherOptions"];

/**
 * A password reset link will be sent to the user's email if it exists. The response must always be success (even if email does not exist). This is to prevent email enumeration attacks.
 */
export const fetchResetPasswordRequest = (
  variables: ResetPasswordRequestVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    ResetPasswordRequestResponse,
    ResetPasswordRequestError,
    ResetPasswordRequestRequestBody,
    {},
    {},
    {}
  >({
    url: "/users/reset-password-request",
    method: "post",
    ...variables,
    signal,
  });

/**
 * A password reset link will be sent to the user's email if it exists. The response must always be success (even if email does not exist). This is to prevent email enumeration attacks.
 */
export const useResetPasswordRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ResetPasswordRequestResponse,
      ResetPasswordRequestError,
      ResetPasswordRequestVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    ResetPasswordRequestResponse,
    ResetPasswordRequestError,
    ResetPasswordRequestVariables
  >({
    mutationFn: (variables: ResetPasswordRequestVariables) =>
      fetchResetPasswordRequest({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResetPasswordError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResetPasswordResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | any[];
};

export type ResetPasswordRequestBody = {
  token: string;
  newPassword: string;
};

export type ResetPasswordVariables = {
  body: ResetPasswordRequestBody;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchResetPassword = (
  variables: ResetPasswordVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    ResetPasswordResponse,
    ResetPasswordError,
    ResetPasswordRequestBody,
    {},
    {},
    {}
  >({ url: "/users/reset-password", method: "post", ...variables, signal });

export const useResetPassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ResetPasswordResponse,
      ResetPasswordError,
      ResetPasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    ResetPasswordResponse,
    ResetPasswordError,
    ResetPasswordVariables
  >({
    mutationFn: (variables: ResetPasswordVariables) =>
      fetchResetPassword({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type SignupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SignupVariables = {
  body: Schemas.UserRegistration;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchSignup = (variables: SignupVariables, signal?: AbortSignal) =>
  programmingForumFetch<
    Responses.CreatedResponse,
    SignupError,
    Schemas.UserRegistration,
    {},
    {},
    {}
  >({ url: "/users/signup", method: "post", ...variables, signal });

export const useSignup = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.CreatedResponse,
      SignupError,
      SignupVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    Responses.CreatedResponse,
    SignupError,
    SignupVariables
  >({
    mutationFn: (variables: SignupVariables) =>
      fetchSignup({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LoginError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedResponse;
}>;

export type LoginResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.AuthToken;
};

export type LoginVariables = {
  body: Schemas.UserLogin;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) =>
  programmingForumFetch<
    LoginResponse,
    LoginError,
    Schemas.UserLogin,
    {},
    {},
    {}
  >({ url: "/users/login", method: "post", ...variables, signal });

export const useLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<LoginResponse, LoginError, LoginVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<LoginResponse, LoginError, LoginVariables>({
    mutationFn: (variables: LoginVariables) =>
      fetchLogin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUserByIdPathParams = {
  userId: number;
};

export type GetUserByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetUserByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type GetUserByIdVariables = {
  pathParams: GetUserByIdPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetUserById = (
  variables: GetUserByIdVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetUserByIdResponse,
    GetUserByIdError,
    undefined,
    {},
    {},
    GetUserByIdPathParams
  >({ url: "/users/{userId}", method: "get", ...variables, signal });

export const useGetUserById = <TData = GetUserByIdResponse>(
  variables: GetUserByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetUserByIdResponse, GetUserByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<GetUserByIdResponse, GetUserByIdError, TData>({
    queryKey: queryKeyFn({
      path: "/users/{userId}",
      operationId: "getUserById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UpdateUserByIdPathParams = {
  userId: number;
};

export type UpdateUserByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type UpdateUserByIdResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type UpdateUserByIdVariables = {
  body: Schemas.UserProfile;
  pathParams: UpdateUserByIdPathParams;
} & ProgrammingForumContext["fetcherOptions"];

/**
 * Can only update own profile
 */
export const fetchUpdateUserById = (
  variables: UpdateUserByIdVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    UpdateUserByIdResponse,
    UpdateUserByIdError,
    Schemas.UserProfile,
    {},
    {},
    UpdateUserByIdPathParams
  >({ url: "/users/{userId}", method: "put", ...variables, signal });

/**
 * Can only update own profile
 */
export const useUpdateUserById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UpdateUserByIdResponse,
      UpdateUserByIdError,
      UpdateUserByIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    UpdateUserByIdResponse,
    UpdateUserByIdError,
    UpdateUserByIdVariables
  >({
    mutationFn: (variables: UpdateUserByIdVariables) =>
      fetchUpdateUserById({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetMeError = Fetcher.ErrorWrapper<{
  status: 403;
  payload: Responses.ForbiddenResponse;
}>;

export type GetMeResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type GetMeVariables = ProgrammingForumContext["fetcherOptions"];

export const fetchGetMe = (variables: GetMeVariables, signal?: AbortSignal) =>
  programmingForumFetch<GetMeResponse, GetMeError, undefined, {}, {}, {}>({
    url: "/users/me",
    method: "get",
    ...variables,
    signal,
  });

export const useGetMe = <TData = GetMeResponse>(
  variables: GetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetMeResponse, GetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<GetMeResponse, GetMeError, TData>({
    queryKey: queryKeyFn({
      path: "/users/me",
      operationId: "getMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUserFollowingPathParams = {
  userId: number;
};

export type GetUserFollowingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetUserFollowingResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserArray;
};

export type GetUserFollowingVariables = {
  pathParams: GetUserFollowingPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetUserFollowing = (
  variables: GetUserFollowingVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetUserFollowingResponse,
    GetUserFollowingError,
    undefined,
    {},
    {},
    GetUserFollowingPathParams
  >({ url: "/users/{userId}/following", method: "get", ...variables, signal });

export const useGetUserFollowing = <TData = GetUserFollowingResponse>(
  variables: GetUserFollowingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUserFollowingResponse,
      GetUserFollowingError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<
    GetUserFollowingResponse,
    GetUserFollowingError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}/following",
      operationId: "getUserFollowing",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserFollowing({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUserFollowersPathParams = {
  userId: number;
};

export type GetUserFollowersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type GetUserFollowersResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserArray;
};

export type GetUserFollowersVariables = {
  pathParams: GetUserFollowersPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetUserFollowers = (
  variables: GetUserFollowersVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetUserFollowersResponse,
    GetUserFollowersError,
    undefined,
    {},
    {},
    GetUserFollowersPathParams
  >({ url: "/users/{userId}/followers", method: "get", ...variables, signal });

export const useGetUserFollowers = <TData = GetUserFollowersResponse>(
  variables: GetUserFollowersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUserFollowersResponse,
      GetUserFollowersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<
    GetUserFollowersResponse,
    GetUserFollowersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}/followers",
      operationId: "getUserFollowers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserFollowers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type FollowUserPathParams = {
  userId: number;
};

export type FollowUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type FollowUserResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type FollowUserVariables = {
  pathParams: FollowUserPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchFollowUser = (
  variables: FollowUserVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    FollowUserResponse,
    FollowUserError,
    undefined,
    {},
    {},
    FollowUserPathParams
  >({ url: "/users/{userId}/follow", method: "post", ...variables, signal });

export const useFollowUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      FollowUserResponse,
      FollowUserError,
      FollowUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    FollowUserResponse,
    FollowUserError,
    FollowUserVariables
  >({
    mutationFn: (variables: FollowUserVariables) =>
      fetchFollowUser({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UnfollowUserPathParams = {
  userId: number;
};

export type UnfollowUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type UnfollowUserResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type UnfollowUserVariables = {
  pathParams: UnfollowUserPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchUnfollowUser = (
  variables: UnfollowUserVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    UnfollowUserResponse,
    UnfollowUserError,
    undefined,
    {},
    {},
    UnfollowUserPathParams
  >({ url: "/users/{userId}/follow", method: "delete", ...variables, signal });

export const useUnfollowUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UnfollowUserResponse,
      UnfollowUserError,
      UnfollowUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    UnfollowUserResponse,
    UnfollowUserError,
    UnfollowUserVariables
  >({
    mutationFn: (variables: UnfollowUserVariables) =>
      fetchUnfollowUser({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/users/{userId}";
      operationId: "getUserById";
      variables: GetUserByIdVariables;
    }
  | {
      path: "/users/me";
      operationId: "getMe";
      variables: GetMeVariables;
    }
  | {
      path: "/users/{userId}/following";
      operationId: "getUserFollowing";
      variables: GetUserFollowingVariables;
    }
  | {
      path: "/users/{userId}/followers";
      operationId: "getUserFollowers";
      variables: GetUserFollowersVariables;
    };
