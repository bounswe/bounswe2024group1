/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useProgrammingForumContext,
  ProgrammingForumContext,
} from "./programmingForumContext";
import type * as Fetcher from "./programmingForumFetcher";
import { programmingForumFetch } from "./programmingForumFetcher";
import type * as Schemas from "./programmingForumSchemas";
import type * as Responses from "./programmingForumResponses";

export type SignUpError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SignUpResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.AuthToken;
};

export type SignUpVariables = {
  body: Schemas.UserRegistration;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchSignUp = (variables: SignUpVariables, signal?: AbortSignal) =>
  programmingForumFetch<
    SignUpResponse,
    SignUpError,
    Schemas.UserRegistration,
    {},
    {},
    {}
  >({ url: "/auth/signup", method: "post", ...variables, signal });

export const useSignUp = (
  options?: Omit<
    reactQuery.UseMutationOptions<SignUpResponse, SignUpError, SignUpVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<SignUpResponse, SignUpError, SignUpVariables>({
    mutationFn: (variables: SignUpVariables) =>
      fetchSignUp({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LoginError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedResponse;
}>;

export type LoginResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.AuthToken;
};

export type LoginVariables = {
  body: Schemas.UserLogin;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) =>
  programmingForumFetch<
    LoginResponse,
    LoginError,
    Schemas.UserLogin,
    {},
    {},
    {}
  >({ url: "/auth/login", method: "post", ...variables, signal });

export const useLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<LoginResponse, LoginError, LoginVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<LoginResponse, LoginError, LoginVariables>({
    mutationFn: (variables: LoginVariables) =>
      fetchLogin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LogoutError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedResponse;
}>;

export type LogoutVariables = ProgrammingForumContext["fetcherOptions"];

export const fetchLogout = (variables: LogoutVariables, signal?: AbortSignal) =>
  programmingForumFetch<undefined, LogoutError, undefined, {}, {}, {}>({
    url: "/auth/logout",
    method: "post",
    ...variables,
    signal,
  });

export const useLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, LogoutError, LogoutVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<undefined, LogoutError, LogoutVariables>({
    mutationFn: (variables: LogoutVariables) =>
      fetchLogout({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type VerifyEmailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type VerifyEmailRequestBody = {
  token: string;
};

export type VerifyEmailVariables = {
  body: VerifyEmailRequestBody;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchVerifyEmail = (
  variables: VerifyEmailVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    VerifyEmailError,
    VerifyEmailRequestBody,
    {},
    {},
    {}
  >({ url: "/auth/verify-email", method: "post", ...variables, signal });

export const useVerifyEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      VerifyEmailError,
      VerifyEmailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    VerifyEmailError,
    VerifyEmailVariables
  >({
    mutationFn: (variables: VerifyEmailVariables) =>
      fetchVerifyEmail({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ResetPasswordError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type ResetPasswordRequestBody = {
  /**
   * @format email
   */
  email: string;
};

export type ResetPasswordVariables = {
  body: ResetPasswordRequestBody;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchResetPassword = (
  variables: ResetPasswordVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    ResetPasswordError,
    ResetPasswordRequestBody,
    {},
    {},
    {}
  >({ url: "/auth/reset-password", method: "post", ...variables, signal });

export const useResetPassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ResetPasswordError,
      ResetPasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    ResetPasswordError,
    ResetPasswordVariables
  >({
    mutationFn: (variables: ResetPasswordVariables) =>
      fetchResetPassword({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUserProfilePathParams = {
  userId: number;
};

export type GetUserProfileError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetUserProfileResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type GetUserProfileVariables = {
  pathParams: GetUserProfilePathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetUserProfile = (
  variables: GetUserProfileVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetUserProfileResponse,
    GetUserProfileError,
    undefined,
    {},
    {},
    GetUserProfilePathParams
  >({ url: "/users/{userId}", method: "get", ...variables, signal });

export const useGetUserProfile = <TData = GetUserProfileResponse,>(
  variables: GetUserProfileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUserProfileResponse,
      GetUserProfileError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<
    GetUserProfileResponse,
    GetUserProfileError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}",
      operationId: "getUserProfile",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserProfile({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UpdateUserProfilePathParams = {
  userId: number;
};

export type UpdateUserProfileError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 403;
      payload: Responses.ForbiddenResponse;
    }
>;

export type UpdateUserProfileResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type UpdateUserProfileVariables = {
  body?: Schemas.UserProfileUpdate;
  pathParams: UpdateUserProfilePathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchUpdateUserProfile = (
  variables: UpdateUserProfileVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    UpdateUserProfileResponse,
    UpdateUserProfileError,
    Schemas.UserProfileUpdate,
    {},
    {},
    UpdateUserProfilePathParams
  >({ url: "/users/{userId}", method: "put", ...variables, signal });

export const useUpdateUserProfile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UpdateUserProfileResponse,
      UpdateUserProfileError,
      UpdateUserProfileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    UpdateUserProfileResponse,
    UpdateUserProfileError,
    UpdateUserProfileVariables
  >({
    mutationFn: (variables: UpdateUserProfileVariables) =>
      fetchUpdateUserProfile({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetMeError = Fetcher.ErrorWrapper<{
  status: 403;
  payload: Responses.ForbiddenResponse;
}>;

export type GetMeResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.UserProfile;
};

export type GetMeVariables = ProgrammingForumContext["fetcherOptions"];

export const fetchGetMe = (variables: GetMeVariables, signal?: AbortSignal) =>
  programmingForumFetch<GetMeResponse, GetMeError, undefined, {}, {}, {}>({
    url: "/users/me",
    method: "get",
    ...variables,
    signal,
  });

export const useGetMe = <TData = GetMeResponse,>(
  variables: GetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetMeResponse, GetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<GetMeResponse, GetMeError, TData>({
    queryKey: queryKeyFn({
      path: "/users/me",
      operationId: "getMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type FollowUserPathParams = {
  userId: number;
};

export type FollowUserError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type FollowUserVariables = {
  pathParams: FollowUserPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchFollowUser = (
  variables: FollowUserVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    FollowUserError,
    undefined,
    {},
    {},
    FollowUserPathParams
  >({ url: "/users/{userId}/follow", method: "post", ...variables, signal });

export const useFollowUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      FollowUserError,
      FollowUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    FollowUserError,
    FollowUserVariables
  >({
    mutationFn: (variables: FollowUserVariables) =>
      fetchFollowUser({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UnfollowUserPathParams = {
  userId: number;
};

export type UnfollowUserError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type UnfollowUserVariables = {
  pathParams: UnfollowUserPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchUnfollowUser = (
  variables: UnfollowUserVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    UnfollowUserError,
    undefined,
    {},
    {},
    UnfollowUserPathParams
  >({
    url: "/users/{userId}/unfollow",
    method: "delete",
    ...variables,
    signal,
  });

export const useUnfollowUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      UnfollowUserError,
      UnfollowUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    UnfollowUserError,
    UnfollowUserVariables
  >({
    mutationFn: (variables: UnfollowUserVariables) =>
      fetchUnfollowUser({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUserFollowersPathParams = {
  userId: number;
};

export type GetUserFollowersError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetUserFollowersResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | Schemas.UserSummary[];
};

export type GetUserFollowersVariables = {
  pathParams: GetUserFollowersPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetUserFollowers = (
  variables: GetUserFollowersVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetUserFollowersResponse,
    GetUserFollowersError,
    undefined,
    {},
    {},
    GetUserFollowersPathParams
  >({ url: "/users/{userId}/followers", method: "get", ...variables, signal });

export const useGetUserFollowers = <TData = GetUserFollowersResponse,>(
  variables: GetUserFollowersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUserFollowersResponse,
      GetUserFollowersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<
    GetUserFollowersResponse,
    GetUserFollowersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}/followers",
      operationId: "getUserFollowers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserFollowers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUserFollowingPathParams = {
  userId: number;
};

export type GetUserFollowingError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetUserFollowingResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | Schemas.UserSummary[];
};

export type GetUserFollowingVariables = {
  pathParams: GetUserFollowingPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetUserFollowing = (
  variables: GetUserFollowingVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetUserFollowingResponse,
    GetUserFollowingError,
    undefined,
    {},
    {},
    GetUserFollowingPathParams
  >({ url: "/users/{userId}/following", method: "get", ...variables, signal });

export const useGetUserFollowing = <TData = GetUserFollowingResponse,>(
  variables: GetUserFollowingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUserFollowingResponse,
      GetUserFollowingError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<
    GetUserFollowingResponse,
    GetUserFollowingError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/{userId}/following",
      operationId: "getUserFollowing",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserFollowing({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type CreateQuestionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
>;

export type CreateQuestionResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.QuestionDetails;
};

export type CreateQuestionVariables = {
  body: Schemas.NewQuestion;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchCreateQuestion = (
  variables: CreateQuestionVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    CreateQuestionResponse,
    CreateQuestionError,
    Schemas.NewQuestion,
    {},
    {},
    {}
  >({ url: "/questions", method: "post", ...variables, signal });

export const useCreateQuestion = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      CreateQuestionResponse,
      CreateQuestionError,
      CreateQuestionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    CreateQuestionResponse,
    CreateQuestionError,
    CreateQuestionVariables
  >({
    mutationFn: (variables: CreateQuestionVariables) =>
      fetchCreateQuestion({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetQuestionDetailsPathParams = {
  questionId: number;
};

export type GetQuestionDetailsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetQuestionDetailsResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.QuestionDetails;
};

export type GetQuestionDetailsVariables = {
  pathParams: GetQuestionDetailsPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetQuestionDetails = (
  variables: GetQuestionDetailsVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetQuestionDetailsResponse,
    GetQuestionDetailsError,
    undefined,
    {},
    {},
    GetQuestionDetailsPathParams
  >({ url: "/questions/{questionId}", method: "get", ...variables, signal });

export const useGetQuestionDetails = <TData = GetQuestionDetailsResponse,>(
  variables: GetQuestionDetailsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetQuestionDetailsResponse,
      GetQuestionDetailsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<
    GetQuestionDetailsResponse,
    GetQuestionDetailsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/questions/{questionId}",
      operationId: "getQuestionDetails",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetQuestionDetails({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UpdateQuestionPathParams = {
  questionId: number;
};

export type UpdateQuestionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 403;
      payload: Responses.ForbiddenResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type UpdateQuestionResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.QuestionDetails;
};

export type UpdateQuestionVariables = {
  body?: Schemas.UpdateQuestion;
  pathParams: UpdateQuestionPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchUpdateQuestion = (
  variables: UpdateQuestionVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    UpdateQuestionResponse,
    UpdateQuestionError,
    Schemas.UpdateQuestion,
    {},
    {},
    UpdateQuestionPathParams
  >({ url: "/questions/{questionId}", method: "put", ...variables, signal });

export const useUpdateQuestion = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UpdateQuestionResponse,
      UpdateQuestionError,
      UpdateQuestionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    UpdateQuestionResponse,
    UpdateQuestionError,
    UpdateQuestionVariables
  >({
    mutationFn: (variables: UpdateQuestionVariables) =>
      fetchUpdateQuestion({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteQuestionPathParams = {
  questionId: number;
};

export type DeleteQuestionError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 403;
      payload: Responses.ForbiddenResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type DeleteQuestionVariables = {
  pathParams: DeleteQuestionPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchDeleteQuestion = (
  variables: DeleteQuestionVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    DeleteQuestionError,
    undefined,
    {},
    {},
    DeleteQuestionPathParams
  >({ url: "/questions/{questionId}", method: "delete", ...variables, signal });

export const useDeleteQuestion = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteQuestionError,
      DeleteQuestionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    DeleteQuestionError,
    DeleteQuestionVariables
  >({
    mutationFn: (variables: DeleteQuestionVariables) =>
      fetchDeleteQuestion({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UpvoteQuestionPathParams = {
  questionId: number;
};

export type UpvoteQuestionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type UpvoteQuestionVariables = {
  pathParams: UpvoteQuestionPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchUpvoteQuestion = (
  variables: UpvoteQuestionVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    UpvoteQuestionError,
    undefined,
    {},
    {},
    UpvoteQuestionPathParams
  >({
    url: "/questions/{questionId}/upvote",
    method: "post",
    ...variables,
    signal,
  });

export const useUpvoteQuestion = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      UpvoteQuestionError,
      UpvoteQuestionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    UpvoteQuestionError,
    UpvoteQuestionVariables
  >({
    mutationFn: (variables: UpvoteQuestionVariables) =>
      fetchUpvoteQuestion({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DownvoteQuestionPathParams = {
  questionId: number;
};

export type DownvoteQuestionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type DownvoteQuestionVariables = {
  pathParams: DownvoteQuestionPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchDownvoteQuestion = (
  variables: DownvoteQuestionVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    DownvoteQuestionError,
    undefined,
    {},
    {},
    DownvoteQuestionPathParams
  >({
    url: "/questions/{questionId}/downvote",
    method: "post",
    ...variables,
    signal,
  });

export const useDownvoteQuestion = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DownvoteQuestionError,
      DownvoteQuestionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    DownvoteQuestionError,
    DownvoteQuestionVariables
  >({
    mutationFn: (variables: DownvoteQuestionVariables) =>
      fetchDownvoteQuestion({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RateQuestionPathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type RateQuestionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 403;
      payload: Responses.ForbiddenResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type RateQuestionResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.QuestionRateResponseDto;
};

export type RateQuestionVariables = {
  body?: Schemas.DifficultyLevelRequestDto;
  pathParams: RateQuestionPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchRateQuestion = (
  variables: RateQuestionVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    RateQuestionResponse,
    RateQuestionError,
    Schemas.DifficultyLevelRequestDto,
    {},
    {},
    RateQuestionPathParams
  >({
    url: "/api/v1/questions/{id}/vote-difficulty",
    method: "post",
    ...variables,
    signal,
  });

export const useRateQuestion = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      RateQuestionResponse,
      RateQuestionError,
      RateQuestionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    RateQuestionResponse,
    RateQuestionError,
    RateQuestionVariables
  >({
    mutationFn: (variables: RateQuestionVariables) =>
      fetchRateQuestion({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetBookmarkedQuestionsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedResponse;
}>;

export type GetBookmarkedQuestionsResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Record<string, any> | Schemas.QuestionSummary[];
};

export type GetBookmarkedQuestionsVariables =
  ProgrammingForumContext["fetcherOptions"];

export const fetchGetBookmarkedQuestions = (
  variables: GetBookmarkedQuestionsVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetBookmarkedQuestionsResponse,
    GetBookmarkedQuestionsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/questions/bookmarked", method: "get", ...variables, signal });

export const useGetBookmarkedQuestions = <
  TData = GetBookmarkedQuestionsResponse,
>(
  variables: GetBookmarkedQuestionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookmarkedQuestionsResponse,
      GetBookmarkedQuestionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<
    GetBookmarkedQuestionsResponse,
    GetBookmarkedQuestionsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/questions/bookmarked",
      operationId: "getBookmarkedQuestions",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBookmarkedQuestions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type BookmarkQuestionPathParams = {
  questionId: number;
};

export type BookmarkQuestionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type BookmarkQuestionVariables = {
  pathParams: BookmarkQuestionPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchBookmarkQuestion = (
  variables: BookmarkQuestionVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    BookmarkQuestionError,
    undefined,
    {},
    {},
    BookmarkQuestionPathParams
  >({
    url: "/questions/{questionId}/bookmarks",
    method: "post",
    ...variables,
    signal,
  });

export const useBookmarkQuestion = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      BookmarkQuestionError,
      BookmarkQuestionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    BookmarkQuestionError,
    BookmarkQuestionVariables
  >({
    mutationFn: (variables: BookmarkQuestionVariables) =>
      fetchBookmarkQuestion({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RemoveQuestionBookmarkPathParams = {
  questionId: number;
};

export type RemoveQuestionBookmarkError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type RemoveQuestionBookmarkVariables = {
  pathParams: RemoveQuestionBookmarkPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchRemoveQuestionBookmark = (
  variables: RemoveQuestionBookmarkVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    RemoveQuestionBookmarkError,
    undefined,
    {},
    {},
    RemoveQuestionBookmarkPathParams
  >({
    url: "/questions/{questionId}/bookmarks",
    method: "delete",
    ...variables,
    signal,
  });

export const useRemoveQuestionBookmark = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RemoveQuestionBookmarkError,
      RemoveQuestionBookmarkVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    RemoveQuestionBookmarkError,
    RemoveQuestionBookmarkVariables
  >({
    mutationFn: (variables: RemoveQuestionBookmarkVariables) =>
      fetchRemoveQuestionBookmark({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetQuestionAnswersPathParams = {
  questionId: number;
};

export type GetQuestionAnswersError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetQuestionAnswersResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data:
    | {
        items?: Schemas.AnswerDetails[];
        totalPages?: number;
      }
    | any[];
};

export type GetQuestionAnswersVariables = {
  pathParams: GetQuestionAnswersPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetQuestionAnswers = (
  variables: GetQuestionAnswersVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetQuestionAnswersResponse,
    GetQuestionAnswersError,
    undefined,
    {},
    {},
    GetQuestionAnswersPathParams
  >({
    url: "/questions/{questionId}/answers",
    method: "get",
    ...variables,
    signal,
  });

export const useGetQuestionAnswers = <TData = GetQuestionAnswersResponse,>(
  variables: GetQuestionAnswersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetQuestionAnswersResponse,
      GetQuestionAnswersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<
    GetQuestionAnswersResponse,
    GetQuestionAnswersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/questions/{questionId}/answers",
      operationId: "getQuestionAnswers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetQuestionAnswers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type CreateAnswerPathParams = {
  questionId: number;
};

export type CreateAnswerError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type CreateAnswerResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.AnswerDetails;
};

export type CreateAnswerVariables = {
  body: Schemas.NewAnswer;
  pathParams: CreateAnswerPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchCreateAnswer = (
  variables: CreateAnswerVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    CreateAnswerResponse,
    CreateAnswerError,
    Schemas.NewAnswer,
    {},
    {},
    CreateAnswerPathParams
  >({
    url: "/questions/{questionId}/answers",
    method: "post",
    ...variables,
    signal,
  });

export const useCreateAnswer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      CreateAnswerResponse,
      CreateAnswerError,
      CreateAnswerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    CreateAnswerResponse,
    CreateAnswerError,
    CreateAnswerVariables
  >({
    mutationFn: (variables: CreateAnswerVariables) =>
      fetchCreateAnswer({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UpdateAnswerPathParams = {
  answerId: number;
};

export type UpdateAnswerError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 403;
      payload: Responses.ForbiddenResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type UpdateAnswerResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.AnswerDetails;
};

export type UpdateAnswerVariables = {
  body?: Schemas.UpdateAnswer;
  pathParams: UpdateAnswerPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchUpdateAnswer = (
  variables: UpdateAnswerVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    UpdateAnswerResponse,
    UpdateAnswerError,
    Schemas.UpdateAnswer,
    {},
    {},
    UpdateAnswerPathParams
  >({ url: "/answers/{answerId}", method: "put", ...variables, signal });

export const useUpdateAnswer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UpdateAnswerResponse,
      UpdateAnswerError,
      UpdateAnswerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    UpdateAnswerResponse,
    UpdateAnswerError,
    UpdateAnswerVariables
  >({
    mutationFn: (variables: UpdateAnswerVariables) =>
      fetchUpdateAnswer({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteAnswerPathParams = {
  answerId: number;
};

export type DeleteAnswerError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 403;
      payload: Responses.ForbiddenResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type DeleteAnswerVariables = {
  pathParams: DeleteAnswerPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchDeleteAnswer = (
  variables: DeleteAnswerVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    DeleteAnswerError,
    undefined,
    {},
    {},
    DeleteAnswerPathParams
  >({ url: "/answers/{answerId}", method: "delete", ...variables, signal });

export const useDeleteAnswer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAnswerError,
      DeleteAnswerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAnswerError,
    DeleteAnswerVariables
  >({
    mutationFn: (variables: DeleteAnswerVariables) =>
      fetchDeleteAnswer({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DownvoteAnswerPathParams = {
  answerId: number;
};

export type DownvoteAnswerError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type DownvoteAnswerVariables = {
  pathParams: DownvoteAnswerPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchDownvoteAnswer = (
  variables: DownvoteAnswerVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    DownvoteAnswerError,
    undefined,
    {},
    {},
    DownvoteAnswerPathParams
  >({
    url: "/answers/{answerId}/downvote",
    method: "post",
    ...variables,
    signal,
  });

export const useDownvoteAnswer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DownvoteAnswerError,
      DownvoteAnswerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    DownvoteAnswerError,
    DownvoteAnswerVariables
  >({
    mutationFn: (variables: DownvoteAnswerVariables) =>
      fetchDownvoteAnswer({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UpvoteAnswerPathParams = {
  answerId: number;
};

export type UpvoteAnswerError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type UpvoteAnswerVariables = {
  pathParams: UpvoteAnswerPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchUpvoteAnswer = (
  variables: UpvoteAnswerVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    UpvoteAnswerError,
    undefined,
    {},
    {},
    UpvoteAnswerPathParams
  >({
    url: "/answers/{answerId}/upvote",
    method: "post",
    ...variables,
    signal,
  });

export const useUpvoteAnswer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      UpvoteAnswerError,
      UpvoteAnswerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    UpvoteAnswerError,
    UpvoteAnswerVariables
  >({
    mutationFn: (variables: UpvoteAnswerVariables) =>
      fetchUpvoteAnswer({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type CreateTagError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
>;

export type CreateTagResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.TagDetails;
};

export type CreateTagVariables = {
  body: Schemas.NewTag;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchCreateTag = (
  variables: CreateTagVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    CreateTagResponse,
    CreateTagError,
    Schemas.NewTag,
    {},
    {},
    {}
  >({ url: "/tags", method: "post", ...variables, signal });

export const useCreateTag = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      CreateTagResponse,
      CreateTagError,
      CreateTagVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    CreateTagResponse,
    CreateTagError,
    CreateTagVariables
  >({
    mutationFn: (variables: CreateTagVariables) =>
      fetchCreateTag({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetTagDetailsPathParams = {
  tagId: string;
};

export type GetTagDetailsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundResponse;
}>;

export type GetTagDetailsResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.TagDetails;
};

export type GetTagDetailsVariables = {
  pathParams: GetTagDetailsPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetTagDetails = (
  variables: GetTagDetailsVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetTagDetailsResponse,
    GetTagDetailsError,
    undefined,
    {},
    {},
    GetTagDetailsPathParams
  >({ url: "/tags/{tagId}", method: "get", ...variables, signal });

export const useGetTagDetails = <TData = GetTagDetailsResponse,>(
  variables: GetTagDetailsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTagDetailsResponse,
      GetTagDetailsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<GetTagDetailsResponse, GetTagDetailsError, TData>({
    queryKey: queryKeyFn({
      path: "/tags/{tagId}",
      operationId: "getTagDetails",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetTagDetails({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type FollowTagPathParams = {
  tagId: string;
};

export type FollowTagError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type FollowTagVariables = {
  pathParams: FollowTagPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchFollowTag = (
  variables: FollowTagVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    FollowTagError,
    undefined,
    {},
    {},
    FollowTagPathParams
  >({ url: "/tags/{tagId}/follow", method: "post", ...variables, signal });

export const useFollowTag = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      FollowTagError,
      FollowTagVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<undefined, FollowTagError, FollowTagVariables>({
    mutationFn: (variables: FollowTagVariables) =>
      fetchFollowTag({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UnfollowTagPathParams = {
  tagId: string;
};

export type UnfollowTagError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 404;
      payload: Responses.NotFoundResponse;
    }
>;

export type UnfollowTagVariables = {
  pathParams: UnfollowTagPathParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchUnfollowTag = (
  variables: UnfollowTagVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    undefined,
    UnfollowTagError,
    undefined,
    {},
    {},
    UnfollowTagPathParams
  >({ url: "/tags/{tagId}/follow", method: "delete", ...variables, signal });

export const useUnfollowTag = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      UnfollowTagError,
      UnfollowTagVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    undefined,
    UnfollowTagError,
    UnfollowTagVariables
  >({
    mutationFn: (variables: UnfollowTagVariables) =>
      fetchUnfollowTag({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type SearchQuestionsQueryParams = {
  /**
   * Search query
   */
  q: string;
  /**
   * Comma-separated list of tag IDs
   */
  tags?: string;
  /**
   * Filter by difficulty level
   */
  difficulty?: Schemas.DifficultyLevel;
  /**
   * Page number
   *
   * @default 1
   */
  page?: number;
  /**
   * Number of items per page
   *
   * @default 20
   */
  pageSize?: number;
};

export type SearchQuestionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SearchQuestionsResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data:
    | {
        items?: Schemas.QuestionSummary[];
        totalItems?: number;
        currentPage?: number;
        totalPages?: number;
      }
    | any[];
};

export type SearchQuestionsVariables = {
  queryParams: SearchQuestionsQueryParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchSearchQuestions = (
  variables: SearchQuestionsVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    SearchQuestionsResponse,
    SearchQuestionsError,
    undefined,
    {},
    SearchQuestionsQueryParams,
    {}
  >({ url: "/search/questions", method: "get", ...variables, signal });

export const useSearchQuestions = <TData = SearchQuestionsResponse,>(
  variables: SearchQuestionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      SearchQuestionsResponse,
      SearchQuestionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<
    SearchQuestionsResponse,
    SearchQuestionsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/search/questions",
      operationId: "searchQuestions",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchSearchQuestions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type SearchUsersQueryParams = {
  /**
   * Search query
   */
  q: string;
  /**
   * Page number
   *
   * @default 1
   */
  page?: number;
  /**
   * Number of items per page
   *
   * @default 20
   */
  pageSize?: number;
};

export type SearchUsersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SearchUsersResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data:
    | {
        items?: Schemas.UserSummary[];
        totalItems?: number;
        currentPage?: number;
        totalPages?: number;
      }
    | any[];
};

export type SearchUsersVariables = {
  queryParams: SearchUsersQueryParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchSearchUsers = (
  variables: SearchUsersVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    SearchUsersResponse,
    SearchUsersError,
    undefined,
    {},
    SearchUsersQueryParams,
    {}
  >({ url: "/search/users", method: "get", ...variables, signal });

export const useSearchUsers = <TData = SearchUsersResponse,>(
  variables: SearchUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<SearchUsersResponse, SearchUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<SearchUsersResponse, SearchUsersError, TData>({
    queryKey: queryKeyFn({
      path: "/search/users",
      operationId: "searchUsers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchSearchUsers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type SearchTagsQueryParams = {
  /**
   * Search query
   */
  q: string;
  /**
   * Page number
   *
   * @default 1
   */
  page?: number;
  /**
   * Number of items per page
   *
   * @default 20
   */
  pageSize?: number;
};

export type SearchTagsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.BadRequestResponse;
}>;

export type SearchTagsResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data:
    | {
        items?: Schemas.TagDetails[];
        totalItems?: number;
        currentPage?: number;
        totalPages?: number;
      }
    | any[];
};

export type SearchTagsVariables = {
  queryParams: SearchTagsQueryParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchSearchTags = (
  variables: SearchTagsVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    SearchTagsResponse,
    SearchTagsError,
    undefined,
    {},
    SearchTagsQueryParams,
    {}
  >({ url: "/search/tags", method: "get", ...variables, signal });

export const useSearchTags = <TData = SearchTagsResponse,>(
  variables: SearchTagsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<SearchTagsResponse, SearchTagsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<SearchTagsResponse, SearchTagsError, TData>({
    queryKey: queryKeyFn({
      path: "/search/tags",
      operationId: "searchTags",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchSearchTags({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetUserFeedQueryParams = {
  /**
   * Feed type
   */
  type: "recent" | "topRated" | "recommended";
  /**
   * Page number
   *
   * @default 1
   */
  page?: number;
  /**
   * Number of items per page
   *
   * @default 20
   */
  pageSize?: number;
};

export type GetUserFeedError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedResponse;
}>;

export type GetUserFeedResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data:
    | {
        items?: Schemas.QuestionSummary[];
        totalItems?: number;
        currentPage?: number;
        totalPages?: number;
      }
    | any[];
};

export type GetUserFeedVariables = {
  queryParams: GetUserFeedQueryParams;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchGetUserFeed = (
  variables: GetUserFeedVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    GetUserFeedResponse,
    GetUserFeedError,
    undefined,
    {},
    GetUserFeedQueryParams,
    {}
  >({ url: "/feed", method: "get", ...variables, signal });

export const useGetUserFeed = <TData = GetUserFeedResponse,>(
  variables: GetUserFeedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetUserFeedResponse, GetUserFeedError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useProgrammingForumContext(options);
  return reactQuery.useQuery<GetUserFeedResponse, GetUserFeedError, TData>({
    queryKey: queryKeyFn({
      path: "/feed",
      operationId: "getUserFeed",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserFeed({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ExecuteCodeError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestResponse;
    }
  | {
      status: 401;
      payload: Responses.UnauthorizedResponse;
    }
  | {
      status: 429;
      payload: Responses.TooManyRequestsResponse;
    }
>;

export type ExecuteCodeResponse = {
  /**
   * Internal status code of the response. An HTTP 200 response with an internal 500 status code is an error response. Prioritize the inner status over the HTTP status.
   *
   * @example 200
   * @example 201
   */
  status: 200 | 201;
  data: Schemas.ExecutionResult;
};

export type ExecuteCodeVariables = {
  body: Schemas.CodeExecution;
} & ProgrammingForumContext["fetcherOptions"];

export const fetchExecuteCode = (
  variables: ExecuteCodeVariables,
  signal?: AbortSignal,
) =>
  programmingForumFetch<
    ExecuteCodeResponse,
    ExecuteCodeError,
    Schemas.CodeExecution,
    {},
    {},
    {}
  >({ url: "/execute-code", method: "post", ...variables, signal });

export const useExecuteCode = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      ExecuteCodeResponse,
      ExecuteCodeError,
      ExecuteCodeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useProgrammingForumContext();
  return reactQuery.useMutation<
    ExecuteCodeResponse,
    ExecuteCodeError,
    ExecuteCodeVariables
  >({
    mutationFn: (variables: ExecuteCodeVariables) =>
      fetchExecuteCode({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/users/{userId}";
      operationId: "getUserProfile";
      variables: GetUserProfileVariables;
    }
  | {
      path: "/users/me";
      operationId: "getMe";
      variables: GetMeVariables;
    }
  | {
      path: "/users/{userId}/followers";
      operationId: "getUserFollowers";
      variables: GetUserFollowersVariables;
    }
  | {
      path: "/users/{userId}/following";
      operationId: "getUserFollowing";
      variables: GetUserFollowingVariables;
    }
  | {
      path: "/questions/{questionId}";
      operationId: "getQuestionDetails";
      variables: GetQuestionDetailsVariables;
    }
  | {
      path: "/questions/bookmarked";
      operationId: "getBookmarkedQuestions";
      variables: GetBookmarkedQuestionsVariables;
    }
  | {
      path: "/questions/{questionId}/answers";
      operationId: "getQuestionAnswers";
      variables: GetQuestionAnswersVariables;
    }
  | {
      path: "/tags/{tagId}";
      operationId: "getTagDetails";
      variables: GetTagDetailsVariables;
    }
  | {
      path: "/search/questions";
      operationId: "searchQuestions";
      variables: SearchQuestionsVariables;
    }
  | {
      path: "/search/users";
      operationId: "searchUsers";
      variables: SearchUsersVariables;
    }
  | {
      path: "/search/tags";
      operationId: "searchTags";
      variables: SearchTagsVariables;
    }
  | {
      path: "/feed";
      operationId: "getUserFeed";
      variables: GetUserFeedVariables;
    };
